# 88. Merge Sorted Array

Это задание с сайта LeetCode ([ссылка](https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)).

Даны два целочисленных массива `nums1` и `nums2`, отсортированных в неубывающем порядке, а также два целых числа `m` и `n`, представляющие количество элементов в `nums1` и `nums2` соответственно.

Необходимо объединить `nums1` и `nums2` в один массив, отсортированный в неубывающем порядке.

Окончательный отсортированный массив не должен возвращаться функцией, а должен храниться внутри массива `nums1`. Для этого длина `nums1` равна `m + n`, где первые `m` элементов — это элементы, которые нужно объединить, а последние `n` элементов равны 0 и должны игнорироваться. Массив `nums2` имеет длину `n`.

## Примеры

### Пример 1
**Ввод**: `nums1 = [1,2,3,0,0,0]`, `m = 3`, `nums2 = [2,5,6]`, `n = 3`  
**Вывод**: `[1,2,2,3,5,6]`  
**Пояснение**: Массивы, которые мы объединяем, — это `[1,2,3]` и `[2,5,6]`. Результат слияния: `[1,2,2,3,5,6]`, где подчёркнутые элементы взяты из `nums1`.

### Пример 2
**Ввод**: `nums1 = [1]`, `m = 1`, `nums2 = []`, `n = 0`  
**Вывод**: `[1]`  
**Пояснение**: Массивы, которые мы объединяем, — это `[1]` и `[]`. Результат слияния: `[1]`.

### Пример 3
**Ввод**: `nums1 = [0]`, `m = 0`, `nums2 = [1]`, `n = 1`  
**Вывод**: `[1]`  
**Пояснение**: Массивы, которые мы объединяем, — это `[]` и `[1]`. Результат слияния: `[1]`. Обратите внимание, что так как `m = 0`, в `nums1` нет элементов. Ноль присутствует только для того, чтобы результат слияния мог поместиться в `nums1`.

## Ограничения
- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-10^9 <= nums1[i], nums2[j] <= 10^9`

## Дополнительный вопрос
Можете ли вы предложить алгоритм, работающий за O(m + n) времени?

## Подход к решению

### Алгоритм: Три указателя (обратный обход)

Реализованное решение использует оптимальный метод с тремя указателями, работающими с конца массивов:

1. **Три указателя**:
   - `pointer_1`: указывает на последний значимый элемент в `nums1` (по индексу `m-1`)
   - `pointer_2`: указывает на последний элемент в `nums2` (по индексу `n-1`)
   - `insert_pos`: указывает на последнюю позицию в `nums1` (по индексу `m+n-1`)

2. **Ключевая идея**: Обрабатывая массивы с конца, мы избегаем перезаписи ещё необработанных элементов в `nums1`. Это исключает необходимость во временных массивах или сложных операциях сдвига.

3. **Процесс**:
   - Сравниваем элементы по указателям `pointer_1` и `pointer_2`
   - Помещаем больший элемент в позицию `insert_pos`
   - Перемещаем соответствующий указатель и `insert_pos` на одну позицию назад
   - Продолжаем, пока один из массивов не будет полностью обработан
   - Копируем оставшиеся элементы из другого массива

### Почему этот подход оптимален

**Сложность по времени**: O(m + n)  
- Каждый элемент из обоих массивов обрабатывается ровно один раз  
- Нет вложенных циклов или повторяющихся операций

**Сложность по памяти**: O(1)  
- Используются только три целочисленные переменные в качестве указателей  
- Массив `nums1` модифицируется на месте, без дополнительного хранилища

### Основные преимущества

1. **Изменение на месте**: Используется уже выделённое пространство в `nums1`, дополнительная память не требуется
2. **Отсутствие сдвигов элементов**: Поскольку обход идёт с конца, мы никогда не перезаписываем ещё необработанные данные
3. **Естественная обработка крайних случаев**: Пустые массивы, одиночные элементы и граничные условия корректно обрабатываются логикой указателей
4. **Стабильная сортировка**: При равенстве элементов сначала размещается элемент из `nums2`, что сохраняет относительный порядок

### Альтернативные подходы

Хотя данное решение является оптимальным, существуют и другие подходы:

1. **Наивный подход**: Скопировать `nums2` в конец `nums1` и отсортировать — O((m+n)log(m+n)) по времени
2. **Три указателя вперёд**: Требует сдвига элементов — в худшем случае O(mn) по времени
3. **Временный массив**: Скопировать результат слияния во временный массив, затем обратно в `nums1` — O(m+n) по времени, но O(m+n) по памяти

Подход с тремя указателями, работающими с конца, является наиболее эффективным решением: он удовлетворяет дополнительному требованию — O(m+n) по времени — и использует всего O(1) дополнительной памяти.